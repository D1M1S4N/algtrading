## â­ OptimizaciÃ³n de un Proyecto Python con Cython

### **1ï¸âƒ£ Estructura del Proyecto**
Supongamos que tu proyecto tiene la siguiente estructura:

```
/mi_proyecto
â”‚â”€â”€ /modulo1
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ funciones1.py
â”‚â”€â”€ /modulo2
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ funciones2.py
â”‚â”€â”€ main.py
â”‚â”€â”€ setup.py
```

Donde `main.py` tiene una funciÃ³n `run()` que usa los mÃ³dulos de `/modulo1` y `/modulo2`.

---

### **2ï¸âƒ£ Convertir el CÃ³digo a Cython**
Para mejorar la velocidad, podemos compilar los mÃ³dulos internos (`funciones1.py`, `funciones2.py`...) a cÃ³digo mÃ¡quina con Cython.

**Crea un archivo `setup.py` en la raÃ­z del proyecto:**

```python
from setuptools import setup, Extension
from Cython.Build import cythonize
import glob

# Encuentra todos los archivos .py en los mÃ³dulos y los compila con Cython
ext_modules = [
    Extension(module.replace("/", ".").replace(".py", ""),
              [module])
    for module in glob.glob("modulo*/**/*.py", recursive=True)
]

setup(
    ext_modules=cythonize(ext_modules, language_level="3"),
)
```
Este script compilarÃ¡ **todos los archivos Python** dentro de `modulo1` y `modulo2` a cÃ³digo optimizado.

---

### **3ï¸âƒ£ Compilar los MÃ³dulos**
Ejecuta en la terminal:

```bash
python setup.py build_ext --inplace
```

Esto generarÃ¡ archivos `.so` (Linux/macOS) o `.pyd` (Windows) en cada mÃ³dulo.
Ejemplo de resultado:
```
/mi_proyecto
â”‚â”€â”€ /modulo1
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ funciones1.cpython-XX-XXX.so  â† âœ… Archivo compilado
â”‚â”€â”€ /modulo2
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ funciones2.cpython-XX-XXX.so  â† âœ… Archivo compilado
â”‚â”€â”€ main.py
â”‚â”€â”€ setup.py
```

Ahora puedes **importar los mÃ³dulos normalmente** en `main.py` sin cambios en el cÃ³digo.

---

### **4ï¸âƒ£ Ejecutar `main.py` con los mÃ³dulos optimizados**
El cÃ³digo en `main.py` seguirÃ¡ igual, pero ahora los mÃ³dulos importados estarÃ¡n compilados:

```python
from modulo1.funciones1 import funcion_x
from modulo2.funciones2 import funcion_y

def run():
    print("Ejecutando optimizado con Cython")
    funcion_x()
    funcion_y()
```
Ejecuta:

```bash
python main.py
```

âœ… **El cÃ³digo es mÃ¡s rÃ¡pido** porque las funciones de `modulo1` y `modulo2` ahora estÃ¡n compiladas.

---

### **5ï¸âƒ£ (Opcional) Compilar tambiÃ©n `main.py`**
Si quieres **compilar `main.py`**, cambia su extensiÃ³n a `main.pyx`, edita `setup.py` asÃ­:

```python
setup(
    ext_modules=cythonize(["main.pyx"] + [module for module in glob.glob("modulo*/**/*.py", recursive=True)], language_level="3"),
)
```
Luego compila:

```bash
python setup.py build_ext --inplace
```

Ejecuta `main` como un **mÃ³dulo compilado**:

```bash
python -c "import main; main.run()"
```

---

### **ğŸš€ Beneficios de esta optimizaciÃ³n**
âœ”ï¸ **Mejor rendimiento** al compilar funciones crÃ­ticas.  
âœ”ï¸ **CÃ³digo ofuscado** (difÃ­cil de leer o copiar).  
âœ”ï¸ **Compatible con Python**, sin cambiar la estructura del proyecto.  

Esto te permite acelerar un **proyecto grande** sin reescribir todo en C++. ğŸ¯ğŸš€

